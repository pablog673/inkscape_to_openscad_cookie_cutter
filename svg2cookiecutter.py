import sys
import svgpath.parser as parser

# colors: RED   = outer wall
#         GREEN = inner wall (holes in the cookie)
#         BLACK = inside feature (not cutting all the way)
#         CYAN  = support


PRELIM = """// OpenSCAD file automatically generated by svg2cookiercutter.py
// parameters tunable by user
noozle=0.6;
perimeters=2;
layer=0.3;
feature_perimeters=2;
tiny_feature_perimeters=1;
flare_multiplier=2;

wallHeight = 12;
minWallThickness = noozle*perimeters;
maxWallThickness = minWallThickness;
minInsideWallThickness = minWallThickness;
maxInsideWallThickness = minWallThickness;

wallFlareWidth = noozle*perimeters*flare_multiplier;
wallFlareThickness = 6*layer;
insideWallFlareWidth = wallFlareWidth;
insideWallFlareThickness = wallFlareThickness;

featureHeight = 8.4;
minFeatureThickness = feature_perimeters*noozle;
maxFeatureThickness = minFeatureThickness;

mintinyFeatureThickness = tiny_feature_perimeters*noozle;
maxtinyFeatureThickness = mintinyFeatureThickness;

connectorThickness = wallFlareThickness;
cuttingTaperHeight = 2*layer;
cuttingEdgeThickness = noozle;


// sizing
//function clamp(t,minimum,maximum) = min(maximum,max(t,minimum));
//function featureThickness(t)      = clamp(t,minFeatureThickness,maxFeatureThickness);
//function wallThickness(t)         = clamp(t,minWallThickness,maxWallThickness);
//function insideWallThickness(t)   = clamp(t,minInsideWallThickness,maxInsideWallThickness);

function featureThickness(t)      = minFeatureThickness;
function tiny_FeatureThickness(t) = mintinyFeatureThickness;
function wallThickness(t)         = minWallThickness;
function insideWallThickness(t)   = minInsideWallThickness;

size = $OVERALL_SIZE$;
scale = size/$OVERALL_SIZE$;

// helper modules: subshapes
module ribbon(points, thickness=1) {
    union() {
        for (i=[1:len(points)-1]) {
            hull() {
                translate(points[i-1]) circle(d=thickness, $fn=8);
                translate(points[i]) circle(d=thickness, $fn=8);
            }
        }
    }
}


module wall(points,height,thickness) {
    module profile() {
        if (height>=cuttingTaperHeight && cuttingTaperHeight>0 && cuttingEdgeThickness<thickness) {
            cylinder(h=height-cuttingTaperHeight+0.001,d=thickness,$fn=8);
            translate([0,0,height-cuttingTaperHeight]) cylinder(h=cuttingTaperHeight,d1=thickness,d2=cuttingEdgeThickness);
        }
        else {
            cylinder(h=height,d=thickness,$fn=8);
        }
    }
    for (i=[1:len(points)-1]) {
        hull() {
            translate(points[i-1]) profile();
            translate(points[i])   profile();
        }
    }
}


module outerFlare(path) {
  difference() {
    render(convexity=10) linear_extrude(height=wallFlareThickness) ribbon(path,thickness=wallFlareWidth);
    translate([0,0,-0.01]) linear_extrude(height=wallFlareThickness+0.02) polygon(points=path);
  }
}

module innerFlare(path) {
  intersection() {
    render(convexity=10) linear_extrude(height=insideWallFlareThickness) ribbon(path,thickness=insideWallFlareWidth);
    translate([0,0,-0.01]) linear_extrude(height=insideWallFlareThickness+0.02) polygon(points=path);
  }
}

module fill(points,path,height) {
  render(convexity=10) linear_extrude(height=height) polygon(points,path);
}


"""

def isRed(rgb):
    return rgb is not None and rgb[0] == 1 and rgb[1] == 0 and rgb[2] ==0

def isGreen(rgb):
    return rgb is not None and rgb[0] == 0 and rgb[1] == 1 and rgb[2] ==0

def isBlack(rgb):
    return rgb is not None and rgb[0] == 0 and rgb[1] == 0 and rgb[2] ==0

def isCyan(rgb):
    return rgb is not None and rgb[0] == 0 and rgb[1] == 1 and rgb[2] ==1
    
def isBlue(rgb):
    return rgb is not None and rgb[0] == 0 and rgb[1] == 0 and rgb[2] ==1

def isWhite(rgb):
    return rgb is not None and rgb[0] == 1 and rgb[1] == 1 and rgb[2] ==1     

class Line(object):
    def __init__(self, pathName, points, fill, stroke, strokeWidth):
        self.pathName = pathName
        self.points = points
        self.fill = fill
        self.stroke = stroke
        self.strokeWidth = strokeWidth
        

    def pathCode(self):
        return self.pathName + ' = scale * [' + ','.join(('[%.3f,%.3f]'%tuple(p) for p in self.points)) + '];'

    def shapesCode(self):
        code = []
        if self.stroke:
            code.append('wall('+self.pathName+','+self.height+','+self.width+');')
            
            if self.hasOuterFlare:
                code.append('  outerFlare('+self.pathName+');')
            if self.hasInnerFlare:
                code.append('  innerFlare('+self.pathName+');')
        #if isCyan(self.fill):
            #code.append('  fill('+self.pathName+','+self.fillHeight+');')
        return '\n'.join(code)
    
    
        
        

class OuterWall(Line):
    def __init__(self, pathName, points, stroke, strokeWidth):
        super(OuterWall, self).__init__(pathName, points, None, stroke, strokeWidth)
        self.height = "wallHeight"
        self.width = "wallThickness(%.3f)" % self.strokeWidth
        self.hasOuterFlare = True
        self.hasInnerFlare = True

class InnerWall(Line):
    def __init__(self, pathName, points, stroke, strokeWidth):
        super(InnerWall, self).__init__(pathName, points, None, stroke, strokeWidth)
        self.height = "wallHeight"
        self.width = "insideWallThickness(%.3f)" % self.strokeWidth
        self.hasOuterFlare = False
        self.hasInnerFlare = True

class Feature(Line):
    def __init__(self, pathName, points, fill, stroke, strokeWidth):
        super(Feature, self).__init__(pathName, points, fill, stroke, strokeWidth)
        self.height = "featureHeight"
        self.width = "featureThickness(%.3f)" % self.strokeWidth
        self.fillHeight = "featureHeight"
        self.hasOuterFlare = False
        self.hasInnerFlare = False
        
class tiny_Feature(Line):
    def __init__(self, pathName, points, fill, stroke, strokeWidth):
        super(tiny_Feature, self).__init__(pathName, points, fill, stroke, strokeWidth)
        self.height = "featureHeight"
        self.width = "tiny_FeatureThickness(%.3f)" % self.strokeWidth
        self.fillHeight = "featureHeight"
        self.hasOuterFlare = False
        self.hasInnerFlare = False

class Connector(Line):
    def __init__(self, pathName, points, fill):
        super(Connector, self).__init__(pathName, points, fill, False, None) # no stroke for connectors, thus no use of self.height and self.width
        self.width = None
        self.fillHeight = "connectorThickness"
        self.hasOuterFlare = False
        self.hasInnerFlare = False
        
def svgToCookieCutter(filename, tolerance=0.1, strokeAll = False):
    lines_others = []
    lines_feature = []
    lines_tiny_Feature = []
    lines_connector=[]
    pathCount = 0;
    minXY = [float("inf"), float("inf")]
    maxXY = [float("-inf"), float("-inf")]

    for superpath in parser.getPathsFromSVGFile(filename)[0]:
        for path in superpath.breakup():
            pathName = '_'+str(pathCount)
            pathCount += 1
            #id=path
            fill = path.svgState.fill
            stroke = strokeAll or path.svgState.stroke is not None
            if not stroke and not fill: continue

            linearPath = path.linearApproximation(error=tolerance)
            points = [(-l.start.real,l.start.imag) for l in linearPath]
            points.append((-linearPath[-1].end.real, linearPath[-1].end.imag))

            if isRed(path.svgState.stroke):
                line = OuterWall('outerWall'+pathName, points, stroke, path.svgState.strokeWidth)
                lines_others.append(line)
            elif isGreen(path.svgState.stroke):
                line = InnerWall('innerWall'+pathName, points, stroke, path.svgState.strokeWidth)
                lines_others.append(line)
            elif isBlack(path.svgState.fill) or isBlack(path.svgState.stroke):
                line = Feature  ('feature'  +pathName, points, fill, stroke, path.svgState.strokeWidth)
                lines_feature.append(line)
            elif isBlue(path.svgState.fill) or isBlue(path.svgState.stroke):
                line = tiny_Feature  ('tiny_Feature'  +pathName, points, fill, stroke, path.svgState.strokeWidth)
                lines_tiny_Feature.append(line)
            elif isCyan(path.svgState.fill):
                line = Connector('connector'+pathName, points, fill)
                lines_connector.append(line)

            else: continue
            
            for i in range(2):
                minXY[i] = min(minXY[i], min(p[i] for p in line.points))
                maxXY[i] = max(maxXY[i], max(p[i] for p in line.points))
            
                            
    size = max(maxXY[0]-minXY[0], maxXY[1]-minXY[1])
    
        
    code = [PRELIM]
    code.append('// data from svg file')
    code += [line.pathCode()+'\n' for line in lines_others]
    code += [line.pathCode()+'\n' for line in lines_feature]
    code += [line.pathCode()+'\n' for line in lines_tiny_Feature]
    code += [line.pathCode()+'\n' for line in lines_connector]
    code.append(
        '// main modules\n'
        'module cookieCutter() {')
    #code.append('union() {')
    #for line in lines
    
    fill_feature = []
    ind=0
    path_points = []
    point_path = []
    
    p = 0
    for line in lines_others:
        code += ['  ' + line.shapesCode()]
        
    for line in lines_feature:
        code += ['  ' + line.shapesCode()]
        if isBlack(line.fill):
            ind+=1
            fill_feature.append(line.pathName)
            for point in line.points:
                point_path.append(str(p))
                p+=1;
            path_points.append('['+','.join(point_path)+']')
            point_path= []
    
    code.append('feature_path = ['+','.join(path_points)+'];')
            
    if ind>0:
        code.append('  fill(concat('+','.join(fill_feature)+'),feature_path,featureHeight);')
        #code.append('difference(){')
        #for feature in fill_feature:
        #    code.append('  fill('+feature+',featureHeight);')
        #code.append('}')
        
    fill_tiny_Feature = []
    ind=0
    path_points = []
    point_path = []
    
    p = 0
            
    for line in lines_tiny_Feature:
        code += ['  ' + line.shapesCode()]
        if isBlue(line.fill):
            ind+=1
            fill_tiny_Feature.append(line.pathName)
            for point in line.points:
                point_path.append(str(p))
                p+=1;
            path_points.append('['+','.join(point_path)+']')
            point_path= []
    
    code.append('tiny_Feature_path = ['+','.join(path_points)+'];')
            
    if ind>0:
        code.append('  fill(concat('+','.join(fill_tiny_Feature)+'),tiny_Feature_path,featureHeight);')
        #code.append('difference(){')
        #for feature in fill_feature:
        #    code.append('  fill('+feature+',featureHeight);')
        #code.append('}')
    
    fill_connector=[]
    ind=0
    path_points = []
    point_path = []
    
    p = 0
    
    for line in lines_connector:
        code += ['  ' + line.shapesCode()]
        if isCyan(line.fill):
            ind+=1
            fill_connector.append(line.pathName)
            for point in line.points:
                point_path.append(str(p))
                p+=1;
            path_points.append('['+','.join(point_path)+']')
            point_path= []
            
    code.append('connector_path = ['+','.join(path_points)+'];')
    if ind>0:
        code.append('  fill(concat('+','.join(fill_connector)+'),connector_path,connectorThickness);')
        
        
        
            
	
   
        # TODO: we should remove the interior of polygonal inner walls
    #code.append('    }\n')
    code.append('    }\n')

    code.append('////////////////////////////////////////////////////////////////////////////////')
    code.append('// final call, use main modules')
    code.append('translate([%.3f*scale + wallFlareWidth/2,  %.3f*scale + wallFlareWidth/2,0])'    % (-minXY[0],-minXY[1]))
    code.append('  cookieCutter();\n')


    return '\n'.join(code).replace('$OVERALL_SIZE$', '%.3f' % size)

if __name__ == '__main__':
    print(svgToCookieCutter(sys.argv[1]))
